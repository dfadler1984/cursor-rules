---
description: TDD-First — Three Laws, R/G/R, Specific→Generic; owner specs; effects seam; logging at Red/Green
globs: **/*.ts,**/*.tsx,**/*.js,**/*.jsx,**/*.mjs,**/*.cjs,**/*.sh
alwaysApply: false
lastReviewed: 2025-11-01
healthScore:
  content: green # Three Laws, cycles, owner specs, effects seam
  usability: green # Reduced from 254→~222 lines, condensed examples
  maintenance: green # Deep maintenance 2025-11-01, verbosity reduced
---

# Rule: TDD-First

> Canonical sources: Core methodology lives here. Language specifics live in `tdd-first-js.mdc` and `tdd-first-sh.mdc`. Quality gates and coverage options live in `test-quality*.mdc`.

## TDD Scope

### When TDD Applies (Hard Gate)

TDD is **required** for all files with executable logic:

- Source code: `**/*.{ts,tsx,js,jsx,mjs,cjs}`
- Shell scripts: `**/*.sh`
- Excludes: `node_modules/**`, `dist/**`, `build/**`, `web/dist/**`

### When TDD Does NOT Apply

TDD is **not required** for:

- Documentation: `**/*.md`, `**/*.mdx`
- Configuration: `**/*.json`, `**/*.yaml`, `**/*.yml`, `**/*.toml`
- Cursor Rules: `.cursor/rules/**/*.mdc`
- Type definitions: `**/*.d.ts` (no runtime behavior)
- Static assets: `**/*.css`, `**/*.html` (unless logic-bearing)

### Decision Tree

```
Is the file a source file with executable logic?
├─ Yes → TDD required (Red → Green → Refactor)
└─ No → Is it documentation, config, or static?
   ├─ Yes → TDD not required, proceed with edit
   └─ Unclear → Ask once: "Does this file define behavior that should be tested?"
```

### Status Transparency

When editing files, note TDD applicability in status updates:

- **In scope**: "TDD: in-scope (source code)" or "TDD: in-scope (shell script)"
- **Exempt**: "TDD: exempt (documentation)" or "TDD: exempt (configuration)"

## Pre-edit Gate

- Before editing list owner spec path(s) colocated with the source file
- Red: add or update a failing owner spec
- Green: implement minimal change to pass
- Refactor: clean up while keeping tests green

## Effects Seam

- Isolate IO/env/time/random behind injected dependencies; test pure resolvers first

## TDD First: Test-Driven Development

## When to use TDD

**Always** when implementing any code changes. No exceptions.

- Bug fixes (test the bug, then fix)
- New features (test the behavior, then implement)
- Refactoring (ensure tests pass before/after)
- API changes (test the contract, then update)
- System updates (test new behavior, then implement)

If you don't understand what behavior to test, ask the engineer for clarification before writing any implementation code.

## The Three Laws and Cycles of TDD

Authoritative formulation per Robert C. Martin (Uncle Bob). These are mandatory gates for any implementation change. The following is a faithful paraphrase with attribution and source links.

### Three Laws (nano-cycle)

1. You may not write any production code unless you have first written a failing test.

2. You may not write more of a test than is sufficient to fail (and not compiling counts as failing).

3. You may not write more production code than is sufficient to pass the currently failing test.

Attribution: Paraphrased from Robert C. Martin’s “The Three Rules of TDD” (see References).

Granularity: Prefer line-by-line alternation between a failing test line and the minimal production line to make it pass, repeating rapidly. Smallest-possible steps reduce rework and keep feedback continuous.

### Red → Green → Refactor (micro-cycle)

1. Red: Add a failing unit test that expresses the next small, observable behavior.

2. Green: Add the minimal production code needed to make that test pass.

3. Refactor: Improve the code’s design with all tests passing; keep behavior unchanged.

Enforcement: Do not proceed to implementation without Red; do not proceed to refactor without Green.

### Specific ↔ Generic (milli-cycle)

- As tests get more specific, the production code should become more generic. Favor solutions that would also satisfy unwritten-but-plausible tests, avoiding overfitting to the last assertion.

When stuck: If making the next test pass requires a large leap outside the nano/micro cycles, backtrack. Delete or revise overly specific recent tests and choose a path that increases code generality while adding test specificity more slowly.

### Hourly boundary check (primary cycle)

- Periodically step back to evaluate architectural boundaries; keep domain logic pure and effects isolated.

## Coverage of effects (must)

- Isolate effects (subprocess, env, FS, network, time/random) behind injected adapters.
- Keep decision logic in pure functions; write failing specs for the pure core first.
- Adapters receive minimal "contract" checks (parsing/shape), not full E2E.

### Example (effects seam)

```ts
// Pure core
export function resolveGithubLogin(input: {
  tokenLogin?: string;
  ciActor?: string;
  ghCliLogin?: string;
  originOwner?: string;
  fallbackUser: string;
}): string {
  return (
    input.tokenLogin ||
    input.ciActor ||
    input.ghCliLogin ||
    input.originOwner ||
    input.fallbackUser
  );
}

// Boundary (CLI)
async function main() {
  const login = resolveGithubLogin({
    tokenLogin: await readFromOctokit(),
    ciActor: process.env.GITHUB_ACTOR?.toLowerCase(),
    ghCliLogin: readFromGhCli(),
    originOwner: readOriginOwner(),
    fallbackUser: readGitUserName(),
  });
  console.log(login);
}
```

## Hard gate (repo‑wide, no skip)

- Scope: applies to all maintained sources: `**/*.{ts,tsx,js,jsx,mjs,cjs,sh}` excluding `node_modules/**`, `dist/**`, `build/**`, `web/dist/**`.
- Owner spec rule (deterministic): for any edited file `f.ext`, the owner spec is the colocated `f.spec.ext` in the same folder. If N sources change, N owner specs must change.
- New files: creating `a.ts` requires creating `a.spec.ts` in the same folder (tsx/js/jsx analogously).
- Public API changes: added/changed exports in `f` must be reflected in `f.spec.*` (add or update the appropriate `describe`).
- Unit focus: even during refactors that touch multiple files, each file’s owner spec must show Red → Green for its own behavior. Integration specs are optional extras, never substitutes.

## Execution protocol (assistant)

- Enforce second-by-second adherence to the Three Laws: introduce only the minimal failing assertion change before writing the minimal production change.
- Run focused tests for the current spec or test name before proceeding to the next step.
- After Green, refactor in small steps while keeping tests green; then proceed to the next Red.

## Language extensions

- This core is language-agnostic. See extensions for ecosystem specifics:
  - JS/TS: `tdd-first-js.mdc` (pre-edit confirmation, focused runs, diff-aware coverage options)
  - Shell: `tdd-first-sh.mdc` (focused harness, owner coupling, behavior evidence)

## Effects seam (functional style)

- Keep resolvers pure: `result = resolver(input, deps)` where `deps` is a plain object of effect functions.
- Put all external effects behind `deps` (subprocess, env, FS, network, time/random, ESM‑only libs).
- CLIs may use dynamic import at the boundary; unit tests never import third‑party ESM directly.
- Unit tests cover resolvers with fake `deps`; adapters receive minimal contract checks when warranted.

## Why TDD

- **Leverage engineering tools**: Use tests to verify correctness, not manual analysis
- **Avoid trial-and-error**: Tests provide immediate feedback on changes
- **Make requirements explicit**: Tests document expected behavior
- **Catch regressions**: Existing tests prevent breaking changes

## Examples

Red → Green cycle: Write failing test for desired behavior, implement minimal code to pass, refactor while keeping tests green.

## Anti-patterns

Implement first test later, manual verification, skip tests for "simple" changes, assertion gaps (must assert observable behavior, not placeholders).

## Do / Don’t

### Do

- Write one failing assertion line, then one minimal production line (nano-cycle granularity).
- Run focused tests between steps (spec path or test name) to keep feedback continuous.
- Increase generality as tests get more specific (Specific↔Generic milli-cycle).
- Isolate effects behind seams and test pure cores; keep adapters thin.
- Pause hourly to check architectural boundaries and keep concerns separated.

### Don’t

- Write more test than needed to fail, or more production than needed to pass.
- Overfit code to the last test; avoid implementations that wouldn’t satisfy plausible unwritten cases.
- Rely on manual verification or placeholder assertions.
- Skip tests for “simple” changes or defer refactoring until later.

## References

- Robert C. Martin, “The Cycles of TDD” (`https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html`)
- Robert C. Martin, “The Three Rules of TDD” (`http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd`)

## Related

- See `testing.mdc` for test structure, naming, and meaningful assertion requirements
- See `tdd-first-js.mdc` for JS/TS enforcement specifics
- See `tdd-first-sh.mdc` for Shell enforcement specifics
