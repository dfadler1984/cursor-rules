---
description: TDD-First — Three Laws, R/G/R, Specific→Generic; owner specs; effects seam; logging at Red/Green
globs: **/*.ts,**/*.tsx,**/*.js,**/*.jsx,**/*.mjs,**/*.cjs,**/*.sh
alwaysApply: true
lastReviewed: 2025-10-05
healthScore:
  content: green
  usability: green
  maintenance: green
---

# Rule: TDD-First

## Pre-edit Gate

- Before editing list owner spec path(s) colocated with the source file
- Red: add or update a failing owner spec
- Green: implement minimal change to pass
- Refactor: clean up while keeping tests green

## Effects Seam

- Isolate IO/env/time/random behind injected dependencies; test pure resolvers first

## TDD First: Test-Driven Development

## When to use TDD

**Always** when implementing any code changes. No exceptions.

- Bug fixes (test the bug, then fix)
- New features (test the behavior, then implement)
- Refactoring (ensure tests pass before/after)
- API changes (test the contract, then update)
- System updates (test new behavior, then implement)

If you don't understand what behavior to test, ask the engineer for clarification before writing any implementation code.

## The Three Laws and Cycles of TDD

### Three Laws (nano-cycle)

1. Write a failing test before any production code.
2. Do not write more test than necessary to fail (or fail to compile).
3. Do not write more production code than necessary to make the failing test pass.

Source: Uncle Bob, The Three Rules of TDD — see link in References.

Granularity: Prefer line-by-line alternation between a failing test line and the minimal production line to make it pass, repeating rapidly. Smallest-possible steps reduce rework and keep feedback continuous.

### Red → Green → Refactor (micro-cycle)

1. Red: Add a failing unit test expressing the next sliver of behavior.
2. Green: Write the minimal production code to pass that test.
3. Refactor: Improve structure with tests green.

### Specific ↔ Generic (milli-cycle)

- As tests get more specific, the production code should become more generic. Favor solutions that would also satisfy unwritten-but-plausible tests, avoiding overfitting to the last assertion.

When stuck: If making the next test pass requires a large leap outside the nano/micro cycles, backtrack. Delete or revise overly specific recent tests and choose a path that increases code generality while adding test specificity more slowly.

### Hourly boundary check (primary cycle)

- Periodically step back to evaluate architectural boundaries; keep domain logic pure and effects isolated.

## Coverage of effects (must)

- Isolate effects (subprocess, env, FS, network, time/random) behind injected adapters.
- Keep decision logic in pure functions; write failing specs for the pure core first.
- Adapters receive minimal "contract" checks (parsing/shape), not full E2E.

### Example (effects seam)

```ts
// Pure core
export function resolveGithubLogin(input: {
  tokenLogin?: string;
  ciActor?: string;
  ghCliLogin?: string;
  originOwner?: string;
  fallbackUser: string;
}): string {
  return (
    input.tokenLogin ||
    input.ciActor ||
    input.ghCliLogin ||
    input.originOwner ||
    input.fallbackUser
  );
}

// Boundary (CLI)
async function main() {
  const login = resolveGithubLogin({
    tokenLogin: await readFromOctokit(),
    ciActor: process.env.GITHUB_ACTOR?.toLowerCase(),
    ghCliLogin: readFromGhCli(),
    originOwner: readOriginOwner(),
    fallbackUser: readGitUserName(),
  });
  console.log(login);
}
```

## Hard gate (repo‑wide, no skip)

- Scope: applies to all maintained sources: `**/*.{ts,tsx,js,jsx,mjs,cjs,sh}` excluding `node_modules/**`, `dist/**`, `build/**`, `web/dist/**`.
- Owner spec rule (deterministic): for any edited file `f.ext`, the owner spec is the colocated `f.spec.ext` in the same folder. If N sources change, N owner specs must change.
- New files: creating `a.ts` requires creating `a.spec.ts` in the same folder (tsx/js/jsx analogously).
- Public API changes: added/changed exports in `f` must be reflected in `f.spec.*` (add or update the appropriate `describe`).
- Unit focus: even during refactors that touch multiple files, each file’s owner spec must show Red → Green for its own behavior. Integration specs are optional extras, never substitutes.

## Pre‑edit confirmation (agent behavior)

- Before any code edit to `**/*.{ts,tsx,js,jsx}`, the assistant must:
  - Infer and list exact owner spec path(s) to add/update (colocated), and
  - Provide a one‑line failing assertion description for each owner spec (the "Red").
- No skip path: if tests cannot be authored as initially framed, adjust the approach (use the FP effects seam) rather than skipping tests.
- One-shot consent for new specs: If creating a new owner spec is required and file creation needs consent, ask once; if no reply, pause.

### Execution protocol (assistant)

- Enforce second-by-second adherence to the Three Laws: introduce only the minimal failing assertion change before writing the minimal production change.
- Run focused tests for the current spec or test name before proceeding to the next step.
- After Green, refactor in small steps while keeping tests green; then proceed to the next Red.

## Shell scripts (Hard gate)

- Hard gate: Any change to `.cursor/scripts/*.sh` (excluding `*.test.sh`) MUST be accompanied by changes to the corresponding `*.test.sh` in the same folder.
- Tests-first flow (Red → Green → Refactor) applies exactly as for JS/TS: write or update a failing test, then implement the minimal change to pass.
- Evidence required in PR:
  - Command: `bash .cursor/scripts/tests/run.sh -k <script-name-without-ext> -v`
  - Paste the focused passing output or link to CI output.
- If direct testing is brittle, extract a pure resolver function and test that seam; do not skip tests.

## Effects seam (functional style)

- Keep resolvers pure: `result = resolver(input, deps)` where `deps` is a plain object of effect functions.
- Put all external effects behind `deps` (subprocess, env, FS, network, time/random, ESM‑only libs).
- CLIs may use dynamic import at the boundary; unit tests never import third‑party ESM directly.
- Unit tests cover resolvers with fake `deps`; adapters receive minimal contract checks when warranted.

## Why TDD

- **Leverage engineering tools**: Use tests to verify correctness, not manual analysis
- **Avoid trial-and-error**: Tests provide immediate feedback on changes
- **Make requirements explicit**: Tests document expected behavior
- **Catch regressions**: Existing tests prevent breaking changes

## Examples

### Bug fix

```ts
// 1. Red: Test the bug
it("handles empty input gracefully", () => {
  expect(() => processInput("")).not.toThrow();
});

// 2. Green: Fix the bug
function processInput(input) {
  if (!input) return null;
  // ... rest of logic
}
```

### New feature

```ts
// 1. Red: Test the new behavior
it("validates CSV format for globs", () => {
  expect(validateGlobs("['invalid']")).toThrow(/invalid format/);
  expect(validateGlobs("valid,pattern")).not.toThrow();
});

// 2. Green: Implement validation
function validateGlobs(globs) {
  if (/[\[\]]/.test(globs)) {
    throw new Error("invalid format; expected CSV");
  }
}
```

## Anti-patterns

- **Implement first, test later**: Leads to incomplete test coverage
- **Manual verification**: Inefficient and error-prone
- **Skip tests for "simple" changes**: Simple changes break things too
- **Assertion gaps**: Tests must assert observable behavior of the system under test (SUT). Avoid placeholders or existence-only checks. Couple assertions to the owner module’s public API, not incidental internals.

## Do / Don’t

### Do

- Write one failing assertion line, then one minimal production line (nano-cycle granularity).
- Run focused tests between steps (spec path or test name) to keep feedback continuous.
- Increase generality as tests get more specific (Specific↔Generic milli-cycle).
- Isolate effects behind seams and test pure cores; keep adapters thin.
- Pause hourly to check architectural boundaries and keep concerns separated.

### Don’t

- Write more test than needed to fail, or more production than needed to pass.
- Overfit code to the last test; avoid implementations that wouldn’t satisfy plausible unwritten cases.
- Rely on manual verification or placeholder assertions.
- Skip tests for “simple” changes or defer refactoring until later.

## References

- Robert C. Martin, “The Cycles of TDD” (`https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html`)
- Robert C. Martin, “The Three Rules of TDD” (`http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd`)

## Related

- See `testing.mdc` for test structure, naming, and meaningful assertion requirements
