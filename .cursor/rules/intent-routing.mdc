---
description: Always-on intent router attaching rules via phrases, keywords, and signals
alwaysApply: true
lastReviewed: 2025-10-22
healthScore:
  content: green # Accurate routing, slash command priorities clear, allowlist trigger added
  usability: green # Well-organized sections, clear slash command documentation
  maintenance: green # Recently reviewed, slash command bypass implemented, /allowlist added
---

# Intent Routing Extensions (ERD Tasks)

## Trigger → Rule Attachment

- Trigger: Phrases matching `create|generate tasks from ERD`
- Attach: `generate-tasks-from-erd.mdc`
- Behavior: Use the two-phase flow — output parent tasks first, pause for “Go,” then emit sub-tasks and relevant files.

## Notes

- Keep terminology consistent: ERD (Engineering Requirements Document), not PRD.
- Follow TDD-first rules when generating sub-tasks.

## Intent-routed rule attachment

This lightweight router keeps context minimal by attaching specific rules only when intent is detected in the user's request. It does not duplicate content; it maps intents → rules.

## Triggers → Rules

- DRY RUN (plan-only)
  - Triggers: Message begins with the exact phrase `DRY RUN:` (highest priority exact phrase trigger)
  - Attach: `dry-run.mdc`, `guidance-first.mdc`
- Session Allowlist Query
  - Triggers: <allowlist-phrase>
    - Phrases: show allowlist|list allowlist|show active allowlist|list session consent|what has standing consent|show session consent|active consent
  - Behavior: Display active session standing consent grants with revoke instructions
  - See: `assistant-behavior.mdc` → Session-scoped standing consent → Grant/Revoke/Query Syntax
- Context Efficiency Gauge
  - Triggers: <gauge-phrase>
    - Phrases: show gauge|context efficiency|how's our context|context health|efficiency gauge|show efficiency|context score
  - Attach: `context-efficiency.mdc`
  - Behavior: Run `.cursor/scripts/context-efficiency-gauge.sh` with estimated inputs (scope, rules count, clarification loops, issues) and display the result in the requested format (default: dashboard)
- Create tests / Testing
  - Triggers: <verb> + <test-term> + [optional: target]
    - Verbs: create|generate|add|write|improve|fix
    - Test terms: test|tests|spec|specs|unit test|jest|coverage|assertion|assertions
    - Targets (optional): for <module>|in <file>
  - Keywords (fallback): coverage|assert|assertion|assertions
  - Exclusions: "how to test" (guidance), "test plan" (planning)
  - Attach: `testing.mdc`, `tdd-first.mdc`, `test-quality.mdc`
- Refactoring
  - Triggers: <refactor-verb> + [optional: target]
    - Verbs: refactor|extract|rename|reorganize|restructure|simplify|optimize
    - Targets (optional): <file>|<function>|<class>|<module>
  - Pre-action gate: Confirm tests exist before refactoring
  - Attach: `refactoring.mdc`, `testing.mdc`
  - Note: Refactoring should keep tests green (no TDD pre-edit unless changing behavior)
- Analysis / Investigation
  - Triggers: <verb> + <analysis-term>
    - Verbs: analyze|investigate|examine|explore|compare|evaluate|assess
    - Analysis terms: pattern|behavior|performance|issue|root cause|impact|options|trade-offs
  - Attach: `guidance-first.mdc` (ask before implementing)
  - Note: If analysis → implementation, confirm transition explicitly
- Implement feature / Fix bug
  - Triggers: <verb> + <change-term> + [optional: target]
    - Verbs: implement|add|fix|update|build|create
    - Change terms: feature|bug|logic|behavior|functionality|component|module|service
    - Targets (optional): in <file>|for <component>|to <module>
  - Exclusions: "should we implement" (guidance), "plan to implement" (planning), "how to implement" (guidance)
  - Consent-after-plan (composite): If the previous assistant turn proposed concrete code edits and the user replies with a consent phrase within one turn (e.g., "proceed", "go ahead", "sounds good", "do it", "ship it"), route to implementation.
  - Attach: `tdd-first.mdc`, `code-style.mdc`, `testing.mdc`
- Hard gate: before any implementation edits, require the universal TDD pre-edit confirmation per `assistant-behavior.mdc` (applies repo-wide).
  - Note: Per `user-intent.mdc` policy, testing + TDD attach by default for implementation intents
- Rules authoring/maintenance
  - Triggers: <verb> + <rules-term>
    - Verbs: write|update|maintain
    - Rules terms: rule|front matter|rules validation
  - Attach: `front-matter.mdc`, `rule-creation.mdc`, `rule-maintenance.mdc`, `rule-quality.mdc`
  - Safeguard: treat soft phrasing (e.g., “we probably need to…”, “should consider…”) as plan-only; ask for explicit consent before repo-wide edits. Confirm target scope (project vs repo-wide) and name files before proceeding.
- Cursor capabilities
  - Triggers: <cursor-term>
    - Terms: cursor features|cursor limits|platform capabilities
  - Attach: `cursor-platform-capabilities.mdc`
- Git usage
  - Triggers: <git-term>
    - Terms: commit|commit message|commits|branch|branch name|branch naming|pre-commit|pre-push|conventional commits|git hooks
  - Attach: `assistant-git-usage.mdc`
- Projects lifecycle (simple)
  - Trigger: message contains <projectsDir> (default: docs/projects)
  - Attach: `project-lifecycle.mdc`
- Project lifecycle (actions)
  - Triggers: <verb> + <lifecycle-term> with project target
    - Verbs: archive|archiving|finalize|complete|close
    - Targets:
      - Path: docs/projects/<slug>
      - Or bare slug: <slug> (ask a one-line confirmation for path if ambiguous)
  - Attach: `project-lifecycle.mdc`
  - On attach, propose the appropriate helper:
    - End-to-end archival: suggest `.cursor/scripts/project-archive-workflow.sh --project <slug> --year <YYYY> --dry-run` first, then the non-dry-run on approval
    - Generate final summary: suggest `.cursor/scripts/final-summary-generate.sh --project <slug> --year <YYYY> [--pre-move]`
    - Validate changed project(s): suggest `.cursor/scripts/project-lifecycle-validate-scoped.sh <slug>`
    - Backfill legacy artifacts: suggest `.cursor/scripts/project-lifecycle-migrate.sh --project <slug>`
- PR triggers: pr|pull request|open pr|create pr → prefer repo script `.cursor/scripts/pr-create.sh` (curl/GitHub API) instead of GH CLI
- ERD creation

  - Triggers: <verb> + <erd-term> [optional: <lite|quick>]
    - Verbs: create|generate|draft|write|produce
    - ERD terms: erd|engineering requirements document|engineering requirements doc|engineering spec|eng spec
    - If the optional modifier `lite` or `quick` is present, select Lite mode
    - Exclusions: review|discuss|read|summarize|compare|analyze (do not trigger creation; ask a brief clarifying question)
    - Prefer: include "for <feature>"; if missing and ambiguous, ask for the feature name
  - Attach: `create-erd.mdc`, `guidance-first.mdc`

- Planning / Specification

  - Triggers: <verb> + <plan-term>
    - Verbs: plan|specify|analyze|outline|draft
    - Plan terms: plan|spec|specification|analysis|acceptance bundle
  - Attach: `spec-driven.mdc`, `guidance-first.mdc`

- Task lists
  - Triggers: task list phrases
    - Terms: task list|update tasks|mark sub-task|mark subtask|check off|relevant files section
  - Attach: `project-lifecycle.mdc` (Task List Process subsection)

## Slash commands

**Git Operations** (HIGHEST PRIORITY — bypass consent gate per `assistant-behavior.mdc`):

- `/commit` → route to `git-slash-commands.mdc` → execute `git-commit.sh`
- `/pr` → route to `git-slash-commands.mdc` → execute `pr-create.sh`
- `/branch` → route to `git-slash-commands.mdc` → execute `git-branch-name.sh`
- `/pr-update` → route to `git-slash-commands.mdc` → execute `pr-update.sh`
- `/status` → suggested (not mandatory) → `git status --porcelain=v1`
- `/diff` → suggested (not mandatory) → `git diff --stat`
- `/log` → suggested (not mandatory) → `git log --oneline -n 10`

**Session Management**:

- `/allowlist` → display active session standing consent grants
  - Output format: bulleted list of commands with revoke instructions
  - See: `assistant-behavior.mdc` → Session-scoped standing consent → Grant/Revoke/Query Syntax

**Other Commands**:

- `/plan <topic>` → route to `spec-driven.mdc` (plan/specify); consent-first; produce plan scaffold
- `/tasks` → route to `project-lifecycle.mdc` (Task List Process subsection); manage/update tasks non-interactively when safe

## File/context signals (supporting)

- If any focused/open/edited path matches `**/*.(spec|test).[tj]s?(x)`, attach `testing.mdc`, `tdd-first.mdc`, `test-quality-js.mdc`.
- If the user mentions "jest", "coverage", or "assert", attach testing rules.
- On implementation verbs (implement/add/fix/refactor/update), attach testing + TDD by default (see `user-intent.mdc`).
- JS/TS files (`*.ts|*.tsx|*.js|*.mjs|*.cjs`): attach `test-quality-js.mdc` for language-specific guidance.
- Shell scripts under `.cursor/scripts/*.sh`: attach `test-quality-sh.mdc` for shell-specific guidance.
- If any focused/open/edited path matches `**/tasks/*.md`, attach `assistant-git-usage.mdc`, `project-lifecycle.mdc`.

## Decision policy (weights)

1. Exact phrase triggers (highest)
   - `DRY RUN:` prefix takes precedence over all other triggers and forces plan-only behavior
2. **Explicit intent verbs** (overrides file signals)
   - Guidance patterns ("how", "what", "should we", "can you explain") override file signals
   - Implementation patterns ("implement", "add", "fix", "build") confirm or override file signals
   - Rationale: User's explicit intent more important than file context
3. Composite consent-after-plan (recent concrete plan + consent phrase within one turn)
4. Keyword fallback (word-boundary intent words) if phrases not found
5. File/context signals (downgraded from tier 4)
6. If still ambiguous and intent suggests implementation, attach testing + TDD and ask one clarifying question

- If ambiguity persists after one clarifying question, do not attach additional rules and pause.

### Intent Override Examples

- Open `*.test.ts` + ask "How should I structure this?" → Attach: `guidance-first` (intent overrides file)
- Open `*.test.ts` + say "Implement login test" → Attach: `testing`, `tdd-first` (intent confirms file)
- Open `*.md` + ask "Should we add X?" → Attach: `guidance-first` (no file signal conflict)

### Role–phase and split-progress advisory

- Prefer phase-consistent routing: when a project is in a planning phase, route “what/why” requests to `spec-driven` over implementation rules.
- Consult split-progress status (if available) to decide between plan vs implement; when unavailable, ask one clarifying question.

## Fuzzy matching & confirmation

### Confidence Tiers

**High Confidence (95%+)**:

- Exact phrase match (e.g., "implement feature X")
- Strong synonym match with context confirmation
- Action: Attach rules immediately, proceed

**Medium Confidence (60-94%)**:

- Fuzzy match: edit distance ≤2 around key phrases
- Synonyms with partial context: "build" vs "implement"
- Soft phrasing with action terms: "should we implement X?"
- Action: Ask 1-line confirmation with explicit options
- Format: "Are you asking for [guidance on approaches] or [implementation of X]?"

**Low Confidence (<60%)**:

- Vague phrasing: "we need better X"
- Missing target or scope: "fix the errors"
- Conflicting signals: guidance verb + implementation context
- Action: Ask clarifying question, do not attach rules until answered

### Fuzzy Signals (Medium Confidence Examples)

- Edit distance ≤2 around key phrases (e.g., "generate tasks from erd" → "gen tasks erd")
- Synonyms: generate|create|draft; tasks|checklist|steps; ERD|engineering requirements
- Partial patterns: "tasks from erd", "erd tasks", "make tasks for <feature>"
- Soft phrasing: "should we implement", "probably need to", "might want to"

### Confirmation Prompt Templates

**Guidance vs Implementation**:

- "Are you looking for guidance on approaches, or would you like me to implement something specific?"

**Planning vs Implementing**:

- "Should I create a plan/spec first, or implement directly?"

**Medium Confidence Example**:

- "I think you want to generate tasks from an ERD and use the two‑phase flow (parent tasks → 'Go' → sub‑tasks). Proceed?"

### Safeguards

- Never auto-create files on medium/low confidence
- Prefer smallest rule set when multiple fuzzy matches; ask which rule the user means
- Include which phrase triggered the prompt in the status note for transparency

## Multi-Intent Handling

### Detection Patterns

- "Plan and implement X"
- "Create spec then build Y"
- "Design and code Z"
- "Analyze and fix W"

### Default Resolution: Plan-First

1. Detect multiple intents in single message
2. Default to planning/analysis phase first
3. Ask confirmation: "Should I start with [plan/spec/analysis], then [implement/build/fix]?"
4. Attach rules for first phase only
5. After completion, ask to proceed to second phase

### Exception: User Explicit Order

- "Implement first, then document" → Honor user's order (no confirmation needed)
- "Skip planning, just build X" → Proceed directly to implementation
- Explicit sequence indicators override default plan-first

## Few-shot routing examples

- "Show gauge" → attach: context-efficiency; run gauge script with current context
- "How's our context?" → attach: context-efficiency; display dashboard
- "Context efficiency" → attach: context-efficiency; show gauge line
- "Add tests for the API client" → attach: testing, tdd-first
- "Can you add a spec for rules-list?" → attach: testing, tdd-first
- "Refactor parse.ts to be pure" → attach: refactoring, testing
- "Fix bug in summary CLI" → attach: tdd-first, code-style, testing
- "Increase Jest coverage for parse" → attach: testing, tdd-first
- "Create an ERD for checkout flow" → attach: create-erd, guidance-first
- "Create ERD" → ask for feature name and full vs lite; then attach: create-erd, guidance-first
- "Review the ERD for checkout flow" → do not attach create-erd; ask a clarifying question
- "Update front matter across rules" → attach: front-matter, rule-maintenance, rule-creation
- "Archive docs/projects/rules-validate-script" → attach: project-lifecycle; propose dry-run of the archive workflow

## Routing Sanity Prompts (for validation)

- "Add tests for X" → expect: attach `testing`, `tdd-first` only
- "Refactor Y" → expect: attach `refactoring` (+ `testing` if JS/TS target), not `tdd-first` unless edits planned
- "Create an ERD for Z" → expect: attach `create-erd`, `guidance-first`
- Guidance-only questions → exclude execution/tooling rules

## Notes

- Keep this file small; do not restate target rule content.
- Prefer the smallest matching set of rules to minimize context.
- If multiple triggers match, attach the union (deduplicated).
- Status transparency: In status updates, include which signal triggered routing (e.g., explicit verb, consent-after-plan, file signal) for traceability.
- Logging: The historical Assistant Learning log guidance has been deprecated. Do not auto-log; capture decisions in project docs as needed.

## Handoff contract

Router outputs a normalized context object for downstream rules:

```json
{
  "intent": "implement|plan|refactor|guidance|git|tasks|erd",
  "targets": ["file paths or feature names"],
  "rule": "tdd-first|spec-driven|assistant-git-usage|project-lifecycle|cursor-platform-capabilities",
  "gates": ["consent", "tdd-owner-spec"],
  "consentState": "required|granted|not-applicable"
}
```

Callees must respect `gates` and update `consentState` as they proceed.

Related

- See `guidance-first.mdc` for handling guidance requests before implementation
- See `user-intent.mdc` for the TDD-by-default policy on implementation intents
- See `00-assistant-laws.mdc` for accuracy and consistency requirements
- See [.cursor/docs/guides/chat-performance/](../docs/guides/chat-performance/) for chat quality patterns (prompt tightening, task splitting, summarization, incident recovery)
