---
description: Testing conventions — meaningful assertions against owner modules; pointers to TDD cycles
globs: **/*.spec*,**/*.test*
alwaysApply: false
lastReviewed: 2025-10-10
healthScore:
  content: green     # Accurate testing conventions
  usability: green   # Clear structure, good examples
  maintenance: green # Recently reviewed, current standards
---

# Testing Overview

- This overview anchors testing conventions and links to focused rules.

## Naming & Colocation

- Prefer file names ending in `.spec.*` over `.test.*`.
- Examples (Do):

```text
src/foo/foo.spec.ts
web/src/components/Button/Button.spec.tsx
```

- Examples (Not that):

```text
src/foo/foo.test.ts
web/src/components/Button/Button.test.tsx
```

- Colocate tests next to the file under test.
- For scripts and libraries under `scripts/**`, place specs alongside sources (e.g., `scripts/git/lib/branch-validate.spec.ts`).
- Test API: prefer `it()` over `test()` with behavior-focused, present-tense titles.

## Structure & Style

- Keep one primary behavior per `it()`; split variants into separate `it()` blocks.
- Prefer clear Arrange-Act-Assert phases; keep setup minimal and explicit.

### Example (Do)

```ts
it("returns the user when present", () => {
  // arrange
  // act
  // assert
});
```

### Example (Avoid)

```ts
test("returns the user when present", () => {
  // large implicit setup, multiple asserts for different behaviors
});
```

## Notes

- Jest config already supports `.spec` and `.test` via `testMatch`.
- Prefer incremental migration: rename when touching a file or alongside nearby changes.

## Environment variables (must)

- Snapshot/restore `process.env` in specs that modify tokens or other env vars:
  - At top of `describe`: `const ORIGINAL_ENV: NodeJS.ProcessEnv = { ...process.env };`
  - `beforeEach`: `process.env = { ...ORIGINAL_ENV };`
  - `afterAll`: `process.env = ORIGINAL_ENV;`
- Prefer wrappers over mutation: expose a `getGithubToken()` helper in the module under test and mock it in specs instead of deleting `process.env.GITHUB_TOKEN`/`GH_TOKEN`.
- If you must simulate missing tokens, delete only within the test and restore immediately after, never globally.

## No placeholders (must)

- Tests must assert observable behavior of the SUT’s public API (values, outputs, effects), not incidental internals or placeholders.

### Examples (good)

```ts
// Owner: src/validateGlobs.ts → src/validateGlobs.spec.ts
it("rejects bracketed globs", () => {
  expect(() => validateGlobs("['invalid']")).toThrow(/invalid format/);
});

// Effects seam injection example
it("formats UTC year-month", () => {
  const fixedNow = () => new Date("2025-10-02T00:00:00Z");
  expect(formatNow(fixedNow)).toBe("2025-10");
});
```

### Anti-examples (avoid)

```ts
// Placeholder assertion — does not exercise SUT behavior
expect(true).toBe(true);

// Existence-only check without behavior
expect(validateGlobs).toBeDefined();
```

## References

- See TDD cycles and Three Laws in `tdd-first.mdc` for the nano/micro/milli cycles and boundary checks.
- Robert C. Martin — The Three Rules of TDD and Red → Green → Refactor (see `tdd-first.mdc` References)

## Related

- See `jest.config.cjs` for `testMatch` alignment
- See `tdd-first.mdc` for TDD methodology
- See `tdd-first-js.mdc` for JS/TS enforcement specifics
- See `tdd-first-sh.mdc` for Shell enforcement specifics

## Quality (Core)

### Purpose

Keep tests meaningful and resistant to false positives with minimal friction. Pair objective execution signals with good structure.

### Core signals (must)

- Owner coupling: a spec should import/invoke its owner module (sibling path) or an extracted pure resolver.
- Meaningful failure: assertions must exercise observable behavior; avoid existence-only checks and placeholders.
- Sabotage spot-check (review practice): temporarily comment out or early-return in the SUT and re-run related tests; they should fail. Revert immediately.

### Structure & effects seam

- Prefer pure resolvers; inject effects (env, filesystem, subprocess, time) as parameters. See `tdd-first.mdc` for methodology.
- Boundary tests: assert parsing/shape, exit codes, and user-visible outputs through seams/spies.

### Linting aids (should)

- Enable test lint rules where available (e.g., expect-expect, no-disabled-tests, no-identical-title).
- Optional denylist in CI to catch obvious placeholders: `expect(true).toBe(true)`, `.skip(`, or "placeholder" in titles.

### Language extensions

- JS/TS specifics (coverage options, commands): `test-quality-js.mdc`, `tdd-first-js.mdc`
- Shell specifics (harness, behavior evidence): `test-quality-sh.mdc`, `tdd-first-sh.mdc`
