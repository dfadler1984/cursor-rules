---
description: Assistant Git usage — commits, branch naming, changesets, and commit gates (tests/lint/types)
alwaysApply: true
lastReviewed: 2025-10-23
healthScore:
  content: green
  usability: green
  maintenance: green
---

# Assistant Git Usage

Defines commit message standards, minimal branch naming guidance, changeset expectations, and when/how to run checks before committing. Optimized for assistant automation and human ergonomics.

## Script-First Default (must)

Before ANY git operation (commit, branch, PR), explicitly check `capabilities.mdc` for available repo scripts:

1. **Query**: "Is there a script in capabilities.mdc for this git operation?"
2. **OUTPUT result**: "Checked capabilities.mdc for [operation]: [found <path> | not found]"
   - Example: "Checked capabilities.mdc for commit: found `.cursor/scripts/git-commit.sh`"
   - Example: "Checked capabilities.mdc for status: not found"
3. **Use script if exists**:
   - Commits: use `git-commit.sh` (especially with bodies/footers)
   - Branch names: use `git-branch-name.sh --task <slug> [--type <type>] [--apply]`
   - PR creation: use `pr-create.sh --title "..." [--body "..."]`
   - PR updates: use `pr-update.sh --pr <number> [--title "..."] [--body "..."]`
4. **Raw git only if no script exists** for that operation

**Rationale**: Repo scripts enforce conventions, format validation, and consistent behavior. This must be verified at pre-send gate per `assistant-behavior.mdc`.

## Commit Messages

- Use Conventional Commits 1.0.0 for headers, scopes, and footers.
  - Reference: https://www.conventionalcommits.org/en/v1.0.0/
- Length limits (must):
  - Title/header ≤72 chars.
  - Body lines ≤100 chars (wrap bullets; use multiple `-m` flags when needed).
- Assistant behavior (hard rule):
  - For any commit with a body, always use the commit helper (`.cursor/scripts/git-commit.sh`).
  - Never call `git commit` directly for multi‑line messages.
- Flexible modes:
  - Quick mode (header only) for small, obvious changes.
    - Example: `fix(parse): handle empty entries`
  - Structured mode (header + body + footers) for multi-file or user‑visible changes, breaking changes, or rationale.
    - Non-interactive example using multiple `-m` flags:
      ```bash
      git commit -m "feat(cli): add endpoints summary" \
        -m "- Prints counts and unique domains" \
        -m "- Updates docs and example.txt" \
        -m "Refs: T123"
      ```
    - Breaking change example:
      ```bash
      git commit -m "feat(api)!: change parse result shape" \
        -m "BREAKING CHANGE: 'requests' renamed to 'entries'"
      ```
- Encourage small, atomic commits. Separate refactors from behavior changes when practical.

## Commit Types for Repository Files

Choose commit types based on **purpose and effect**, not file format:

**Rules (`.cursor/rules/*.mdc`)**:
- **NOT `docs`** (even though they're markdown)
- Use `feat` for new rules or rule enhancements (e.g., adding examples)
- Use `fix` for rule corrections or bug fixes
- Use `refactor` for reorganization without behavioral change
- **Rationale**: Rules affect assistant behavior; they are features, not documentation

**Scripts (`.cursor/scripts/*`)**:
- Use `feat` for new scripts or capabilities
- Use `fix` for script bugs
- Use `refactor` for internal improvements

**Documentation (`docs/`, `README.md`)**:
- Use `docs` for changes that describe existing behavior
- Use `feat` if documenting new features alongside implementation

**Example**:
- ✅ `feat(laws): add practical scenario examples` (rule enhancement)
- ✅ `fix(tdd): correct scope check logic` (rule correction)
- ❌ `docs(laws): add examples` (incorrect; rules are features)

## Branch Naming

- Preferred pattern: `<github-login>/<type>-<feature-name>-<task>`
  - Types follow Conventional Commits (feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert).
  - Example: `userLogin/feat-thing-endpoints-summary`
- Minimum requirement: `<github-login>/<task>`.
- The helper script resolves the GitHub login from the `origin` remote; it falls back to `git config user.name` when origin is not GitHub.

### Enforcement

- Pre-push branch name validation should run via your git hooks; enforce the branch naming policy (see `.cursor/scripts/git-branch-name.sh`).
- Login derivation precedence: origin owner (GitHub) → CI actor (`GITHUB_ACTOR`) → token-authenticated API lookup (Octokit) → `git config user.name` fallback.

## Pull Requests (curl + GitHub API; no GH CLI dependency)

- Use the repo script to create PRs via the GitHub API:
  - `.cursor/scripts/pr-create.sh --title "..." [--body "..."] [--base <branch>] [--head <branch>]`
- Auth: set `GITHUB_TOKEN` or `GH_TOKEN` in your environment. Fine‑grained or classic tokens are supported; minimum scope to open PRs is repo access for the target repository.
- Fallback: when no token is available, the script prints a compare URL you can open in the browser.

### Multi-line PR bodies (required quoting)

- Use ANSI-C quoting or a heredoc to pass multi-line bodies to `pr-create.sh` / `pr-update.sh`.
- Do not pass plain double-quoted strings with literal `\n`; GitHub will store backslash-n instead of real newlines.
- Examples:

```bash
BODY=$'## Summary\n…real newlines…'
bash .cursor/scripts/pr-update.sh --head <branch> --body "$BODY"
```

```bash
BODY="$(cat <<'EOF'
## Summary
…real newlines…
EOF
)"
bash .cursor/scripts/pr-create.sh --title "…" --body "$BODY"
```

### PR description policy (must)

- Always submit a fully filled PR description. Replace placeholders with concrete, repo-specific details.
- Include:
  - Summary: one short paragraph of what changed and why.
  - Changes: bullets of key edits (files or areas), user-facing impact if any.
  - Why: the problem addressed; alternatives considered if relevant.
  - Acceptance & Validation: checklist of checks and how to verify.
  - Risk & Rollout: compat notes, rollback, comms.
  - Citations: links for external references (docs/specs), if used.
- If the template is injected by the script, pass a complete `--body` to avoid placeholders.

## Changesets (must)

- Always include a Changeset in PRs that modify repository behavior or published artifacts (rules, scripts, docs that affect workflows, or any code changes).
  - Default: add a changeset. Only skip with the `skip-changeset` label and explicit maintainer consent.
  - Assistant default (must): When opening a PR with any code/rules/docs change, create a changeset before PR creation.

### Changeset Policy by File Type

**Always require changeset** (no `skip-changeset`):
- `.cursor/rules/*.mdc` changes (rules affect behavior; always warrant version bump)
- `.cursor/scripts/*` changes (tooling changes affect workflows)
- Code changes (any `.js`, `.ts`, `.sh` under `src/` or similar)

**May skip changeset** (with explicit consent):
- `docs/` markdown files (describes existing behavior)
- `README.md` updates (unless documenting new features)
- Comment-only changes
- Test fixtures or example files

**Rationale**: Rules are features that affect assistant behavior, not documentation. Even adding examples to existing rules improves usability and warrants a patch bump.
    - Interactive: prompt to run `npx changeset`.
    - Non-interactive: create `.changeset/<slug>.md` with the selected bump.
- Author workflow:

  - Interactive (preferred locally): `npx changeset` → follow prompts → commit the generated file under `.changeset/`.
  - Non‑interactive (automation friendly): create a file like `.changeset/<slug>.md` with front matter and summary:

    ```md
    ---
    "cursor-rules": patch
    ---

    Short one‑line summary of the change.
    ```

- PR hygiene (must):
  - Ensure the PR includes the `.changeset/*.md` file.
  - PR body includes an acceptance checkbox: “Changeset included”.
  - After merge, approve the automatic “Version Packages” PR to update `CHANGELOG.md` and `VERSION`.

## Commit Gate (Tests/Lint/Types)

- During TDD: run only tests relevant to the change for fast feedback.
- Before commit (local gate): run your repository's full checks when reasonably fast (tests, lint, types). Prefer targeted runs during iteration and full runs before committing.
- Test colocation (must): colocate specs next to sources; no `__tests__/` directories.
  - CI guard: `yarn guard:no-tests-dir` fails if `**/__tests__/**` exists.

### Hooks and repo scripts

- Pre-commit hooks should call local scripts without extra path args; scripts should auto-detect targets.
- Example: use `.cursor/scripts/lint-workflows.sh` (no args); it resolves `.github/workflows` internally.
- Lockfile enforcement: a pre-commit step should verify that `yarn.lock` is staged whenever `package.json` changes.

## Staging and Cleanup

- Stage only intended files. Remove temporary artifacts and generated files not meant for source control before committing.
- Never commit secrets. Redact tokens from messages and logs.
  - See: `security.mdc` for comprehensive security guidelines

## Cross-References

- Task lists and ERD-derived tasks should reference this rule for commit and gate expectations.
  - See: `generate-tasks-from-erd.mdc`

## Sources / Inspiration

- Conventional Commits 1.0.0 — https://www.conventionalcommits.org/en/v1.0.0/
- Task List Management Guidelines — https://raw.githubusercontent.com/snarktank/ai-dev-tasks/refs/heads/main/process-task-list.md

## Tooling scripts

- Create Conventional Commit messages:
  - `.cursor/scripts/git-commit.sh --type <type> [--scope <scope>] --description <desc> [--body <line>]... [--footer <f>]... [--breaking <desc>]`
  - Types validated: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert
- Suggest a branch name from your git user:
  - `.cursor/scripts/git-branch-name.sh --task <slug> [--type <feat|fix|...>] [--feature <name>] [--apply]`
  - Validates branch type (feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert)
